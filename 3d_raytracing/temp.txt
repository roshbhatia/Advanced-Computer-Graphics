psuedocode for reflections


////////////

reflection_calc(point1, point2, depth, rgb)
	//Instance vars
	xyzi[4]
	up[3]
	normal[3]
	temprgb[3]
	
	//End of Instance vars

	find_intersection_and_tvalue(point1, point2,xyzi)
	obj = xyzi[3] //obj is the z value of the point we're looking at
	
	if obj == -1 
		rgb = {0, 0, 0} // if the z value DNE we know it hasn't intersected with an object
		return //we return as we don't need to calculate anything else

	//Past this is the recursive parts of the function

	//Up should be the same hypothetically but in case it isn't this is what we're doing
	up[0] = xyzi[0], up[1] = xyzi[1] + 1, up[2] = xyzi[2]

	get_normal_eye_space(xyzi, imat[obj], obj_type[obj], normal)
	
	Ligh
